# vim: ft=conf tw=80

2022-12-31
   Took the simple approach. Any user-defined type has 0 slots. May come back to
   bite me later, but it's not the most complicated thing to change.

   Do I begin work on the merge phase first? Or fix up the type checking and
   evaluation?

   Typecheck and evaluation first. Return to merging after.
   - [x] parser
   - [x] symtab   phase
   - [x] flatten  phase
   - [ ] semantic phase
   - [ ] compiler phase
   - [ ] merge    phase


2023-01-01
   May need a rhs None/Empty type, to foil lhs' Any type. Use %empty as ident,
   as with sections. User's can't declare empty types.

   Complex types missing a subtype get implicit ANY:
   > things @list;       ->   things @list[any];
   > person @record;     ->   person @record[any];
   > stuff  @list[list]  ->   stuff  @list[list[any]];

   Empty expressions return implicit NONE:
   > things: [];         ->  list[none]
   > person: {};         ->  record[none]
   > stuff:  [[]];       ->  list[list[none]]

   Type match if:
      - lhs.kind == ANY
      - rhs.kind == EMPTY
      - lhs.kind == rhs.kind


2023-01-02
   The above works pretty well, excepting in the case of list items. Something
   like this...
   > _ @list[list[str]]: [[1], [1], []];

   ...does not fail. Only the final list element is used as the subtype of the
   list. When comparing for homogeneity, `list[-2] == list[-1]` because the rhs
   is of type NONE, which auto-matches. Within lists, need to do a strict and
   deep comparison.

   It's an expression, so no Type(ANY). Will have inner NONEs for lists (and
   records?). Currently I think can only occur within lists.
