# vim: ft=conf tw=80

2022-12-31
   Took the simple approach. Any user-defined type has 0 slots. May come back to
   bite me later, but it's not the most complicated thing to change.

   Do I begin work on the merge phase first? Or fix up the type checking and
   evaluation?

   Typecheck and evaluation first. Return to merging after.
   - [x] parser
   - [x] symtab   phase
   - [x] flatten  phase
   - [x] semantic phase
   - [x] compiler phase
   - [x] merge    phase


2023-01-12
   Working on merging. Thinkies...

   * Need to iterate by symbol table
   * Expressions may be overwritten
   *

   Merging...
   Expressions    Expressions (if present) are always overwritten. An empty
                  rhs will not overwrite the lhs.

   Typedefs       A Type(TYPE) in the symbol table must match exactly if
                  declared, and may never be overwritten. It may only serve
                  as "documentation" in imported files.

   Types          Shares the same rules as typedefs.

   Sections       Merge expressions, copy over overflow, descend into its symtab
                  and iterate anew.


   I would like to potentially allow for the idea of "equal to, or greater"
   specificity for types, but the holdup is records.

   Not sure how to express a record of greater specificity.

   I think it's really
   * Disallow additional `.next`
   * Allow additional `.subtype`.

   Two records match if they have the same number of parameters, and any "open"
   Type(ANY) slots are filled.

   INVALID: rec[str, str] -> rec[str, str, int]
   INVALID: rec[str, str] -> rec[str, int]
   VALID:   rec[list]     -> rec[list[str]]

   May be able to use the same `type:eq` function. Need to look at it again.
   See if there's a difference in the semantic use, vs this one here. Feels
   the same tbh. Though it also allows for a rhs of None. Don't want to
   overwrite `none` into the lhs's type.


   The "import all overflow" can be a problem if...

   a.conf
   ---
   import 'b.conf';
   import 'c.conf';
   full_name @rec[str, str];
   ---

   b.conf
   ---
   full_name: ["John", "Doe"];
   random_key @int: 7;
   ---

   c.conf
   ---
   full_name: ["Marcus", "Aurelius"];
   random_key @str: "";
   ---

   Both 'b.conf' and 'c.conf' are referring to the keys defined in 'a.conf'.
   They happen to create the same intermediate key, `random_key`, but define it
   differently. A type error is thrown in 'c.conf', which is very confusing for
   the user.

   For the future:
   Require `import` statements have an `as <identifier>`. The compiled result
   is entered into the symtab as a section. Or maybe do a `from ... import ...`.
   I dunno yet. Either way feels like it's a little more explicit, and has the
   potential to avoid a classification of problems.


2023-01-14
   The above now works. Need to fix the following.

   - [x] `@list` is not being read as `@list[any]` as intended
   - [x] Records don't yet exist beyond their typedef

   And these would be nice to have, but non-essential.
   - [ ] Symbol that maps to the `%container` section for absolute refs
         Kinda like using `^` to represent "the top", it makes sense visually

   - [ ] Identifiers are considered "undefined" too soon, not able to reference
         known variables/types up the heirarchy
         - This feels like it would be a good use for "exports", making
           something available down the chain, and "imports" pulling in
           variables up the chain

           a.conf
           ---
           from 'b.conf' import [
              Bindings, paths
           ];

           typedef rec[path, str] as Path;
           export [ Path ];
           ---


           b.conf
           ---
           # These aren't imported up the chain:
           version @list[int] : [1, 0, 0];
           author  @str       : "Marcus Aurelius";

           # These are imported.
           Bindings {
              key1 : "KeySym_A";
              key2 : "KeySym_B";
           }

           paths @Path: [
              { "~/bin",   "copy" },
              { "~/music", "link" },
           ]
           ---
