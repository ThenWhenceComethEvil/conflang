Think I need to make another more intermediate IR.
:: source -> tokens -> AST -> IR -> bash

AST      Information for semantic analysis, cursor information

IR       Should be a nearly-finished tree, though with terminal sentinel nodes
         instead of raw values. Perhaps also additional meta-information.
----

An array like:
   [ "one", "two" ]

Compiles to:
   declare -a _IR_1=(
      _IR_2
      _IR_3
   )
   declare -- _IR_2="one"
   declare -- _IR_3="two"

Hmm, IR nodes should contain...
   [symtab]    :: symbol table name this node belongs to
   [node]      :: reference back to the AST node name
   [name]      :: for convenience, node.name.value (needed? helpful?)

...but maybe only for expressions. Not sections or variable declarations.


Maybe instead compiles to:
   declare -a _IR_1=(
      _IR_2
      _IR_3
   )
   declare -A _IR_2=(
      [symtab]=_SYMTAB_2
      [node]=_NODE_2
      [value]="one"
   )
   declare -A _IR_3=(
      [symtab]=_SYMTAB_2
      [node]=_NODE_3
      [value]="two"
   )


This doesn't actually solve for the original problem of deferred compilation of
something like:
   item  : array> 1;
   array : ["one", "two"];

In the above case, we cannot determine the reference to `item` until determining
the reference of `array`, and compiling what it points to.


Build a dependency graph, and compile in order? I don't know how to do this,
even not in bash. Imagine there would be a much greater degree of complexity
here.


Hmm, I think only a tree is possible. As one variable may not be assigned to
multiple values, we must have a tree. Ultimately all variables must resolve to a
"raw" expression.


Building a tree, and assigning each node a "depth" allows us to defer references
until their prerequisites have been compiled. Should be able to then assign each
AST_NODE to a pass of the reference compiler.

Revisiting:
   item1: array> 0;
   array: [ "one", "two" ]

Pass1 compiles to:
   declare -a _IR_1=_IR_2     # item1 = unary...
   declare -a _IR_2=''        # unary [UNRESOLVED]

   declare -a _IR_3=(
      _IR_4
      _IR_5
   )
   declare -- _IR_6="one"
   declare -- _IR_7="two"

   REF_MAP=(
      [_NODE_2]=_IR_2
   )

Pass2 compiles to:
   declare -a _IR_1=_IR_2
   declare -a _IR_2=_IR_4     <--  "${_IR_3[0]}"
   ...
   REF_MAP=()


To do this...
   item1: array> 0;
   array: [ "one", "two" ]

...must become...
   # Has a reference. Everything after the reference must be of a greater depth,
   # and the "container" that holds in (in this case the unary expression) is on
   # the same level.
   _NODE_1=(
      [depth]=0
      [value]='item1'
   )
   _NODE_2=(  # unary
      [depth]=1
      [left]='_NODE_3'
      [right]='_NODE_4'
   )
   _NODE_3=(
      [depth]=1
      [value]='array'
   )
   _NODE_4=(
      [depth]=2
      [value]=0
   )

   # Building the array. Only leaf nodes here, no references.
   _NODE_5=(
      [depth]=0
      [value]='array'
      [items]='_NODE_6'
   )
   _NODE_6=(
      _NODE_7
      _NODE_8
   )
   _NODE_7=(
      [depth]=0
      [value]='one'
   )
   _NODE_8=(
      [depth]=0
      [value]='two'
   )


e: "three"
f: e
array: ["one", "two", e];
c: array> 1;
b: c
d: c
a: b

depth:

  0                                          (e: "three")
                                             /  \
  1                 (array: ["one", "two", e])(f: e)
                       |
  2              (c: array> 0)
                /   \
  3       (d: c) (b: c)
                  |
  4           (a: b)



Or more simplified:

         e
       /   \
    array   f
      |
      c
     / \
    d   b
        |
        a


So, now we know what we're *trying* to achieve. I guess that's good enough for
one night. Tomorrow we can start reasoning about the steps required to *get*
there.


Can we assume any expressions must be a 0-depth? Depends if we allow references
in arrays. If not, and they may only contain raw values, then all value leaf
nodes must be 0.

Sections and variable declarations are always 0. We can create the skeleton
itself, it is only the expressions of variable declarations that have ambiguity
in their compilation order.

Assuming:
   S1 {
      a: c;
      b: c;
      c: "this"
   }

Results in the skeleton:
   _SK_0=(
      [_SK_1]=''
      [_SK_2]=''
      [_SK_3]='_SK_4'
   )
   _SK_4='this'


We can then make a map parallel to the AST/SYMTAB that associates the AST_NODE
with the _SK_$n node.

Will additionally need a map for the depth of each AST node. While compiling,
hitting a node of greater depth causes us to create the _SK_$n node but set as
empty. Should try to make this idempotent, and using as few tests as possible.

Maybe it would honestly be faster to intitially just create the skeleton with
zero values. We then just check depth.
   if (( $DEPTH > ${DEPTH_MAP[$NODE]} )) ; then
      continue
   fi

Assuming:
   S1 {
      a: c;
      b: c;
      c: "this"
   }

Results in pass1
   _SK_0=(
      [_SK_1]=''
      [_SK_2]=''
      [_SK_3]=''
   )

Results in pass2
   _SK_0=(
      [_SK_1]=''
      [_SK_2]=''
      [_SK_3]='_SK_4'
   )
   _SK_4="this"

Results in pass3
   _SK_0=(
      [_SK_1]='_SK_3'
      [_SK_2]='_SK_3'
      [_SK_3]='_SK_4'
   )
   _SK_4="this"

Which compiles to...
   _D_0=(
      [_D_1]='_D_4'
      [_D_2]='_D_4'
      [_D_3]='this'
   )

UH OH! Hmm. I may need to think this through more. Clearly we can't just resolve
all the references by 1 level, because then refs are going to point to the
now-deleted terminal nodes.


Either way it feels like there's an edge case. Either it's an edge case where I
need to handle the terminal raw expr, or it's an edge case where I need to
handle the reference. Gotta come up with a general solution that fits for both
of them.


Gotta work through the problem above a little more.


Assuming:
   S1 {
      a: c;
      b: c> 0;
      c: [[1, 2], 3];
   }

Results in pass1
   _SK_0=(
      [_SK_1]=''
      [_SK_2]=''
      [_SK_3]=''
   )

Results in pass2
   _SK_0=(
      [_SK_1]=''
      [_SK_2]=''
      [_SK_3]='_SK_4'
   )
   _SK_4=(
      _SK_5       # [1, 2]
      _SK_6       # 3
   )
   _SK_5=(
      _SK_7       # 1
      _SK_8       # 2
   )
   _SK_6='3'
   _SK_7='1'
   _SK_8='2'

Results in pass3
   _SK_0=(
      [_SK_1]='_SK_4'      map.get('c') ->  _SK_4
      [_SK_2]='_SK_5'      map.get('c') ->  _SK_4 -> [0] -> _SK_5
      [_SK_3]='_SK_4'
   )
   _SK_4=(
      _SK_5       # [1, 2]
      _SK_6       # 3
   )                       
   _SK_5=(                 
      _SK_7       # 1
      _SK_8       # 2
   )
   _SK_6='3'
   _SK_7='1'
   _SK_8='2'

Which compiles to...
   _D_0=(
      [_D_1]='_D_4'
      [_D_2]='_D_5'
      [_D_3]='_D_4'
   )
   _D_4=(
      _D_5
      3
   )                       
   _D_5=(                 
      1
      2
   )


Maybe make helper function(s) for the below.
   function ref_is_open {
      local -n node="${NODE}"
      local -n _name="${node[name]}"
      local -- name="${_name[value]}"

      local -n symtab="${SYMTAB}"
      local -n symbol="${symtab[name]}"
      local -n target_node="${symbol[node]}"
      
      # Return if there is an open ref for this node that still must be
      resolved.
      [[ "${REF_MAP[$target_node]}" ]]
   }

   function at_depth {
      local depth="${DEPTH_MAP[$NODE]}"
      [[ $depth -eq $DEPTH ]]
   }

Can test if refs should be resolved at this level like so:
   ref_is_open || return;
   at_depth    || return;

Expressions that may have dependencies (e.g., an array with a ref as a member)
can be assessed with just:
   at_depth || return;

Huh so it seems like to get it to work, we need to have the references point not
to the variable, but to point to the expression. Which I believe is what I
actually tried in a4860532c23d or so. Getting back to the problem that didn't
work above again.

Assuming:            #          AST NODES
   S1 {              #  S1's expr  ::  AST1 (section)
      a: c;          #  a's  expr  ::  AST2 (identifier, value: 'c')
      b: c> 0;       #  b's  expr  ::  AST3 (index, left: 'c', right: 0)
      c: [1, 2];     #  c's  expr  ::  AST4 (array, items: [AST5, AST6])
   }

Pass 0.
Create a skeleton with every node in the symbol table. Expressions are left
empty and compiled next. Can honestly probably fill in "raw" expressions in this
phase as well.
   SK0=(
      [SK1]=''
      [SK2]=''
      [SK3]=''
   )

Pass 1.
   SK0=(             #    EXPR_MAP{}
      [SK1]=''       #  
      [SK2]=''       #  
      [SK3]='SK4'    #
   )                 #
   SK4=(             #   AST4  ->  SK4
      SK5            #
      SK6            #
   )                 #
   SK5=1             #   AST5  ->  SK5
   SK6=2             #   AST6  ->  SK6

Pass 2.
   SK0=(
      [SK1]='SK4'    #  symtab['c'] -> AST4 -> EXPR_MAP['AST4'] -> SK4
      [SK2]='SK5'    #  symtab['c'] -> AST4 -> EXPR_MAP['AST4'] -> SK4 -> [0]
      [SK3]='SK4'
   )
   SK4=(
      SK5
      SK6
   )
   SK5=1
   SK6=2

Shit, same problem with leaf expressions. The reference needs to resolve twice
to the value itself, instead of the name of the value. This is **not** the case
with arrays/sections though. Bah.

Maybe if we try again without the intermediate variable for terminal exprs?

Assuming:            #          AST NODES
   S1 {              #  S1's expr  ::  AST1 (section)
      a: c;          #  a's  expr  ::  AST2 (identifier, value: 'c')
      b: c> 0;       #  b's  expr  ::  AST3 (index, left: 'c', right: 0)
      c: [1, 2];     #  c's  expr  ::  AST4 (array, items: [AST5, AST6])
   }

Pass 0.
Create a skeleton with every node in the symbol table. Expressions are left
empty and compiled next. Can honestly probably fill in "raw" expressions in this
phase as well.
   SK0=(
      [SK1]=''
      [SK2]=''
      [SK3]=''
   )

Pass 1.
   SK0=(             #    EXPR_MAP{}
      [SK1]=''       #  
      [SK2]=''       #  
      [SK3]='SK4'    #
   )                 #
   SK4=(             #   AST4  ->  SK4
      1              #   AST5  ->  '1'
      2              #   AST6  ->  '2'
   )                 #

Pass 2.
   SK0=(
      [SK1]='SK4'    #  symtab['c'] -> AST4 -> EXPR_MAP['AST4'] -> SK4
      [SK2]='1'      #  symtab['c'] -> AST4 -> EXPR_MAP['AST4'] -> SK4 -> [0]
      [SK3]='SK4'
   )
   SK4=(
      1
      2
   )


Huh. Seems the approach I was going with originally does work... don't need the
IR at all, but I do need some way of first generating the dependency tree.
