Nuked the old version of this, I think I have a better writeup in my paper
notes anyway. Will type that up here shortly.

At its core, conflang does this:

> #[pseudocode]
> fn main(src):
>    ast = parse(src)
>    while includes > 0:
>       ast += parse(includes.pop())
>
>    child = None
>    if constrain:
>       child = parse(src)
>       while includes > 0:
>          child += parse(includes.pop())
>
>    parent_symtab = mk_symtab(ast)
>    child_symtab  = mk_symtab(child)
>
>    ast, symtab = merge(parent_symtab, child_symtab)
>    semantics(ast, symtab)
>    compile(ast)


From here, need to
   1. Change how constrain works
      - The result of an `identify_constraint_file` should be appending a single
        file to FILES[]. The precedence should operate top -> bottom, in which
        the highest prec is on the bottom. The function will iterate and return
        the last file found. Example: ['found', 'found', 'not found'] would
        return the file at index 1.
      - There must be at least one constrain file found (if there is a constrain
        statement), else a parse error is thrown.
   2. Change where %use statements are "compiled"
      - Realistically, %use statements aren't "compiled". They're kinda just
        entered into the symbol table under a new name. Example, 'std/math' may
        go into the symtab as ['math']=Symbol(['fn']='_aabbcc').
      - These should be parsed and entered into the symtab just after the built-
        in symbols (int, str, bool, type, etc.).

Running list of things that will be necessary for this to work:
 - [ ]. Types as a valid expression
          - Requires changing how subscription works, everything will need to
            shift to bracket syntax
          - Honestly this is a better approach that we should've shifted to
            some time ago
          - Allows the user to supply a .conf file with their module that
            states permissible types
 - [ ]. Compiling a type expression returns the name of the compiled TYPE_$n
        node.
          - May be useful in situations such as this one in which using a
            type as value should return the TYPE to the programmer
          - There may also be situations useful for end users for this
            behavior
          - Takes us one step closer to being able to call functions from the
            global scope. Maybe internal references don't need to use '%'
            afterall, save it for parser statements
