Need to think through the validation more.
I don't think it really makes sense any more to use a vm, despite how cool it would be.
Next project I can implement a stack-based vm in Bash.

For now it probably makes the most sense to have the validation represented by an array of tuples.

[
   {
      data: <name_of_DATA>
      fn:   <function_name>
      args: <name_of_ARGS>
   },
   {...}
]

Example:

```confl
things (array:path): [
   'p1',
   'p2',
   'p3'
] {
   each is_dir.
   each hasattr "read".
   each hasattr "write".
};

stuff (path): './dir' {
   exists?
}
```

Compiles to:

```
[
   {
      data: _DATA_1
      fn:   each
      args: [is_dir]
   },
   {
      data: _DATA_1
      fn:   each
      args: [hasattr, "read"]
   },
   {
      data: _DATA_1
      fn:   each
      args: [hasattr, "write"]
   },
   {
      data: _DATA_2
      fn:   exists-test
      args: []
   }
]
```

Definitely need some way of defining function signatures so we can typecheck the validation.
Did think of doing it natively:

```confl
name: "exist";
variatic: true;

# Argument 0 must be a function. The rest can be anything, as it's variatic.
# Else it would require the arguments to conform to exactly what is here.
arguments (array:type): [
   fn
];
```

Hmm, but then how can we typecheck the passed-in function's arguments?

Want to reduce to an absolutely minimum the things that fail at runtime.
Though now that I think about it, the execution of the "validation" phase still isn't "runtime".
If we consider the flow...

```
compile -> validate -> user's application
```

Anything that fails in validation is still prior to the user's application actually running.

What would some of the builtin functions be?
   - each fn arg1..argN
      - For iterating over lists, iter calls $fn ${args[@]} on each element
      -  ```
         function each {
            local -- fn_name="$1" ; shift
            local -a args=( "$@" )

            local -n symbol="${SYMTAB[$fn_name]}"
            if [[ ! $symbol ]] ; then
               raise cannot_call "$fn_name"
            fi

            local -n fn="${symbol[
         }
         ```
   - hasattr attr:str
      -  ```
         function hasattr-test {
            if [[ ! -e "$DATA" ]] ; then
               raise validation_error "hasattr() expecting existing file/directory"
            fi

            case "$1" in
               "read")     [[ -r $DATA ]] ;;
               "write")    [[ -w $DATA ]] ;;
               "execute")  [[ -x $DATA ]] ;;

               *) raise argument_error 'hasattr'  'expecting ["read", "write", "execute"]'
                  ;;
            esac
         }

         function hasattr-directive {
            case "$1" in
               "read")     chmod +r ;;
               "write")    chmod +w ;;
               "execute")  chmod +x ;;

               *) raise argument_error 'hasattr'  'expecting ["read", "write", "execute"]'
                  ;;
            esac
         }
         ```
   - isdir file:path
      -  ```
         function isdir-test {
            [[ -d "$DATA" ]]
         }

         function isdir-directive {
            mkdir -p "$DATA"
         }
         ```
   - isfile file:path
      -  ```
         function isfile-test {
            [[ -f "$DATA" ]]
         }

         function isfile-directive {
            touch "$DATA"
         }
         ```
