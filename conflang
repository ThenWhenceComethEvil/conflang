#!/bin/bash

# Current environment's variables. By diffing with the later dump of
# variables, we can determine which were defined here, and what was pre-
# existing from the environment. If the user tries to reference an
# environment variable that we've stomped on, we can accurately report that
# here.
ifs="$IFS" ; IFS=$'\n'
for line in $(declare -p) ; do
   if [[ "$line" =~ ^declare\ -(-|[xraAin]+)\ ([^=]+) ]] ; then
      ENV_START+=( "${BASH_REMATCH[2]}" )
   fi
done
IFS="$ifs"


function usage {
cat <<EOF
usage: $(basename "${BASH_SOURCE[0]}") [option] FILE

options
   None.
EOF

exit "$1"
}


function argparse {
   local -a positional=()
   local -a invalid=()

   while [[ $# -gt 0 ]] ; do
      case "$1" in
         -h | --help)
               usage 0
               ;;

         #-*)  if [[ $positional ]] ; then
         #        echo "flags & keyword args may not follow positional args"
         #     fi

         *)    positional+=( "$1" )
               shift
               ;;
      esac
   done

   if [[ ! $positional ]] ; then
      raise no_input
   fi

   if [[ "${positional[0]}" == '-' ]] ; then
      INPUT=/dev/stdin
   else
      INPUT="${positional[0]}" 
   fi
}


function init_globals {
   # Declares all the necessary global variables for each run. Wrapping into a
   # setup() function allows for easier BATS testing.

   # Path to initial file to compile.
   declare -g INPUT=

   # Symbol table holding the name of the SYMTAB_$n, and a nameref to that
   # symtab.
   declare -g GLOBALS=

   # The root NODE_$n of the parent and child AST trees.
   declare -g PARENT_ROOT= CHILD_ROOT=

   # Shouldn't code file names/paths into the generated output. If the user has
   # the same file *data*, but it's in a different place, we shouldn't have to
   # re-compile the output.  An array of files allows us to map a static file
   # INDEX (stored in the output data), to the possibly dynamic path to the
   # file.
   declare -ga FILES=()
   declare -gi FILE_IDX=

   # Stores the $ROOT after each `parse()`. The idx of a root node here should
   # correspond to it's matching INCLUDE_$n from the INCLUDES[] array. Example:
   #> INCLUDE_ROOT [ NODE_10,    NODE_20    ]
   #> INCLUDES     [ INCLUDE_01, INCLUDE_02 ]
   # Meaning...
   # Take the contents of INCLUDE_ROOT[0].items, and drop them into
   # INCLUDES[0].target.items.
   declare -ga INCLUDE_ROOT=()  INCLUDES=()
}


# If sourced, exit. Equiv. to Python's >if __name__ == '__main__'
# Nothing below this line will run if sourced, only if invoked directly.
if [[ ! "${BASH_SOURCE[0]}" == "$0" ]] ; then
   # Return is valid at the top level if sourced.
   return 0
fi

# shellcheck disable=SC2155,SC2164
declare -g PROGDIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" ; pwd )
declare -g LIBDIR="${PROGDIR}/lib"

# shellcheck source=./lib/utils.sh
source "${LIBDIR}"/utils.sh

# shellcheck source=./lib/errors.sh
source "${LIBDIR}"/errors.sh

# shellcheck source=./lib/debug.sh
source "${LIBDIR}"/debug.sh

# shellcheck source=./lib/lexer.sh
source "${LIBDIR}"/lexer.sh

# shellcheck source=./lib/parser.sh
source "${LIBDIR}"/parser.sh
# Exports:
#  TOKENS[]
#  TOKEN_$n

# shellcheck source=./lib/compiler.sh
source "${LIBDIR}"/compiler.sh
# Exports (USER ACCESSIBLE):
#  _DATA_ROOT
#  _DATA_*

# shellcheck source=./lib/api.sh
source "${LIBDIR}"/api.sh
# Exports (USER ACCESSIBLE):
#  conf()   - query data
#  RV       - result of query
#

init_globals
argparse "$@"
do_parse
do_compile

#conf homedir
#echo "${RV@Q}"
