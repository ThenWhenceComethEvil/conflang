#!/bin/bash

# Current environment's variables. When the user queries an env var (e.g., PATH)
# we need to make sure it isn't something that's been stomped on by a variable
# declared within this script itself. By returning the value of SNAPSHOT[$var],
# we're guaranteed to never have stomped a value.
declare -gA SNAPSHOT=()
while IFS= read -r -d '' line ; do
   key="${line%%=*}"
   val="${line#*=}"
   SNAPSHOT["$key"]="$val"
done < <(env --null)


function usage {
cat <<EOF
usage: $(basename "${BASH_SOURCE[0]}") [option] FILE

options
   -h | --help    show this message and exit
   -o | --out     file for compiled output

Unless --out is specified, compilation result is dumped to stdout.

EOF

exit "$1"
}


function init_globals {
   # Declares all the necessary global variables for each run. Wrapping into a
   # setup() function allows for easier BATS testing.

   # Path to initial file to compile.
   declare -g INPUT=

   # Compiled output tree file location. Defaults to stdout.
   declare -g DATA_OUT=/dev/stdout

   # Symbol table holding the name of the SYMTAB_$n, and a nameref to that
   # symtab.
   declare -g GLOBALS=

   # The root NODE_$n of the parent and child AST trees.
   declare -g PARENT_ROOT= CHILD_ROOT=

   # Shouldn't code file names/paths into the generated output. If the user has
   # the same file *data*, but it's in a different place, we shouldn't have to
   # re-compile the output.  An array of files allows us to map a static file
   # INDEX (stored in the output data), to the possibly dynamic path to the
   # file.
   declare -ga FILES=()
   declare -gi FILE_IDX=

   # Stores the $ROOT after each `parse()`. The idx of a root node here should
   # correspond to it's matching INCLUDE_$n from the INCLUDES[] array. Example:
   #> INCLUDE_ROOT [ NODE_10,    NODE_20    ]
   #> INCLUDES     [ INCLUDE_01, INCLUDE_02 ]
   # Meaning...
   # Take the contents of INCLUDE_ROOT[0].items, and drop them into
   # INCLUDES[0].target.items.
   declare -ga INCLUDE_ROOT=()  INCLUDES=()
}


function argparse {
   local -a positional=()
   local -a invalid=()

   while [[ $# -gt 0 ]] ; do
      case "$1" in
         -h | --help)
               usage 0
               ;;

         -o | --out)
               shift
               DATA_OUT="$1"
               shift
               ;;

         *)    positional+=( "$1" )
               shift
               ;;
      esac
   done

   if [[ ! $positional ]] ; then
      raise no_input
   elif [[ ${#positional[@]} -gt 1 ]] ; then
      raise invalid_positional_arguments "${positional[@]}"
   fi

   if [[ "${positional[0]}" == '-' ]] ; then
      INPUT=/dev/stdin
   else
      INPUT="${positional[0]}" 
   fi
}


# If sourced, exit. Equiv. to Python's >if __name__ == '__main__'
# Nothing below this line will run if sourced, only if invoked directly.
if [[ ! "${BASH_SOURCE[0]}" == "$0" ]] ; then
   # Return is valid at the top level if sourced.
   return 0
fi

# shellcheck disable=SC2155,SC2164
declare -g PROGDIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" ; pwd )
declare -g LIBDIR="${PROGDIR}/../lib"

# shellcheck source=./lib/errors.sh
source "${LIBDIR}"/errors.sh

# shellcheck source=./lib/utils.sh
source "${LIBDIR}"/utils.sh

# shellcheck source=./lib/lexer.sh
source "${LIBDIR}"/lexer.sh

# shellcheck source=./lib/parser.sh
source "${LIBDIR}"/parser.sh

# shellcheck source=./lib/pre-compile.sh
source "${LIBDIR}"/semantics.sh

# shellcheck source=./lib/compiler.sh
source "${LIBDIR}"/compiler.sh

init_globals
argparse "$@"
do_parse
do_compile

declare -p ${!_DATA_*} > "$DATA_OUT"
