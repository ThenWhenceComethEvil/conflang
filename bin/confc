#!/bin/bash
set -eo pipefail

if [[ $CONFC_TRACEBACK ]] ; then
   trap '(( $? )) && traceback 2' EXIT
fi

# When querying an env var, must ensure it hasn't been stomped by a variable
# declared within this script itself. Returning value of SNAPSHOT[$var].
declare -gA SNAPSHOT=()
while IFS= read -r -d '' line ; do
   key="${line%%=*}"
   val="${line#*=}"
   SNAPSHOT["$key"]="$val"
done < <(env --null)


function usage {
cat <<EOF
usage: $(basename "${BASH_SOURCE[0]}") [option] FILE

options
   -h | --help    show this message and exit
   -o | --out     file for compiled output

Unless --out is specified, compilation result is dumped to stdout.

EOF

exit "$1"
}


function globals:init {
   # Compiled output tree file location.
   declare -g OUTPUT=/dev/stdout

   # The root of the compiled output.
   declare -g _SKELLY_ROOT=

   # Array of "file objects", containing tuple of {AST, Symtab} pointers.
   declare -gA FILES=()
   #
   # @type
   declare -g  FILE
   declare -gi _FILE_NUM=0
   declare -gi _FILE_LINES_NUM=0

   # Array of absolute file paths to parse. Preserves order of imports, as
   # FILES is an associative array.
   declare -ga IMPORTS=()

   # Poor man's `type()` function.
   declare -gA TYPEOF=()

   # @type
   declare -g  TOKEN
   declare -gi _TOKEN_NUM=0

   # @type
   declare -g  NODE
   declare -gi _NODE_NUM=0

   # @type
   declare -g  LOCATION=
   declare -gi _LOC_NUM=0

   # @type
   declare -g  TYPE=
   declare -gi _TYPE_NUM=0

   # @type
   declare -g  SYMBOL=
   declare -gi _SYMBOL_NUM=0

   # @type
   declare -g  SYMTAB=
   declare -gi _SYMTAB_NUM=0

   # Maps a symtab node to its parent.
   declare -gA SYMTAB_PARENT=()

   # Drops anchor at the start of a declaration, expression, etc. For error
   # reporting.
   # @type
   declare -g  ANCHOR=''

   # Results of the parsing, symtab, and import phases.
   declare -g  FINAL_AST
   declare -g  FINAL_SYMTAB
}


function argparse {
   local -a positional=()
   local -a invalid=()

   while [[ $# -gt 0 ]] ; do
      case "$1" in
         -h | --help)
               usage 0
               ;;

         -o | --out)
               shift
               OUTPUT="$1"
               shift
               ;;

         *)    positional+=( "$1" )
               shift
               ;;
      esac
   done

   if [[ ! $positional ]] ; then
      raise no_input
   elif [[ ${#positional[@]} -gt 1 ]] ; then
      raise argument_error "${positional[@]}"
   fi

   if [[ "${positional[0]}" == '-' ]] ; then
      declare -g INPUT=/dev/stdin
   else
      declare -g INPUT="${positional[0]}"
   fi
}


# main()
# @description
#  Wrapper function to kick off the whole parse, typcheck, and evaluation
#  pieline.
#
# @env   INPUT
# @set   FILE
# @set   IMPORTS[]
function main {
   globals:init
   file:new ; file:resolve "$INPUT"  "$PWD"

   for (( idx = 0 ; idx < ${#IMPORTS[@]} ; ++idx )) ; do
      local path="${IMPORTS[$idx]}"
      local file="${FILES[$path]}"
      local -n file_r="$file"

      echo "$path"

      file:parse "$file"

      local -n ast_r="$NODE"
      local -n header_r="${ast_r[header]}"
      local -n items_r="${header_r[items]}"

      for node in "${items_r[@]}" ; do
         if [[ "${TYPEOF[$node]}" == import ]] ; then
            local -n node_r="$node"
            local -n import_path_r="${node_r[path]}"
            local import_path="${import_path_r[value]}"

            # Location node of the import statement, for error reporting.
            local loc="${node_r[location]}"

            # The file the import is relative *to*, i.e. the dirname of the
            # calling file.
            local -n loc_r="$loc"
            local parent="${loc_r[file]%/*}"

            file:new
            file:resolve  "$import_path"  "$parent"  "$loc"
         fi
      done
   done

   #walk:flatten "$NODE"
   #dependency_to_map
   #dependency_sort

   #for ast_node in "${ORDERED_DEPS[@]}" ; do
   #   walk:semantics "$ast_node"
   #done

   #walk:compiler "$NODE"
}


# If sourced, exit. Equiv. to Python's >if __name__ == '__main__'
# Nothing below this line will run if sourced, only if invoked directly.
if [[ ! "${BASH_SOURCE[0]}" == "$0" ]] ; then
   # Return is valid at the top level if sourced.
   return 0
fi

# shellcheck disable=SC2155,SC2164
declare -g PROGDIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" ; pwd )
declare -g LIBDIR="${PROGDIR}/../lib"

# shellcheck source=./lib/errors.sh
source "${LIBDIR}"/errors.sh

# shellcheck source=./lib/lexer.sh
source "${LIBDIR}"/lexer.sh

# shellcheck source=./lib/parser.sh
source "${LIBDIR}"/parser.sh

# shellcheck source=./lib/imports.sh
source "${LIBDIR}"/imports.sh

# shellcheck source=./lib/symbols.sh
source "${LIBDIR}"/symbols.sh

# shellcheck source=./lib/pre-compile.sh
source "${LIBDIR}"/semantics.sh

# shellcheck source=./lib/compiler.sh
source "${LIBDIR}"/compiler.sh

# shellcheck source=./lib/compiler.sh
source "${LIBDIR}"/api.sh

argparse "$@"
main

#declare -f conf > "$OUTPUT"
[[ ${!_SKELLY_*} ]] && declare -p ${!_SKELLY_*} > "$OUTPUT"  ||:
[[ ${!_DATA_*}   ]] && declare -p ${!_DATA_*}   > "$OUTPUT"  ||:
