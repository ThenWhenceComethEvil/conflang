#!/bin/bash
set -eo pipefail
trap '(( $? )) && traceback 2' EXIT

# Current environment's variables. When the user queries an env var (e.g., PATH)
# we need to make sure it isn't something that's been stomped on by a variable
# declared within this script itself. By returning the value of SNAPSHOT[$var],
# we're guaranteed to never have stomped a value.
declare -gA SNAPSHOT=()
while IFS= read -r -d '' line ; do
   key="${line%%=*}"
   val="${line#*=}"
   SNAPSHOT["$key"]="$val"
done < <(env --null)

function usage {
cat <<EOF
usage: $(basename "${BASH_SOURCE[0]}") [option] FILE

options
   -h | --help    show this message and exit
   -o | --out     file for compiled output

Unless --out is specified, compilation result is dumped to stdout.

EOF

exit "$1"
}


function argparse {
   local -a positional=()
   local -a invalid=()

   while [[ $# -gt 0 ]] ; do
      case "$1" in
         -h | --help)
               usage 0
               ;;

         -o | --out)
               shift
               DATA_OUT="$1"
               shift
               ;;

         *)    positional+=( "$1" )
               shift
               ;;
      esac
   done

   if [[ ! $positional ]] ; then
      raise no_input
   elif [[ ${#positional[@]} -gt 1 ]] ; then
      raise invalid_positional_arguments "${positional[@]}"
   fi

   if [[ "${positional[0]}" == '-' ]] ; then
      INPUT=/dev/stdin
   else
      INPUT="${positional[0]}" 
   fi
}


# If sourced, exit. Equiv. to Python's >if __name__ == '__main__'
# Nothing below this line will run if sourced, only if invoked directly.
if [[ ! "${BASH_SOURCE[0]}" == "$0" ]] ; then
   # Return is valid at the top level if sourced.
   return 0
fi

# shellcheck disable=SC2155,SC2164
declare -g PROGDIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" ; pwd )
declare -g LIBDIR="${PROGDIR}/../lib"

# shellcheck source=./lib/errors.sh
source "${LIBDIR}"/errors.sh

# shellcheck source=./lib/utils.sh
source "${LIBDIR}"/utils.sh

# shellcheck source=./lib/lexer.sh
source "${LIBDIR}"/lexer.sh

# shellcheck source=./lib/parser.sh
source "${LIBDIR}"/parser.sh

# shellcheck source=./lib/pre-compile.sh
source "${LIBDIR}"/semantics.sh

# shellcheck source=./lib/compiler.sh
source "${LIBDIR}"/compiler.sh

# shellcheck source=./lib/compiler.sh
source "${LIBDIR}"/api.sh

init_globals
argparse "$@"

utils:parse
utils:eval

#declare -f conf > "$DATA_OUT"
[[ ${!_SKELLY_*} ]] && declare -p ${!_SKELLY_*} > "$DATA_OUT"  ||:
[[ ${!_DATA_*}   ]] && declare -p ${!_DATA_*}   > "$DATA_OUT"  ||:
