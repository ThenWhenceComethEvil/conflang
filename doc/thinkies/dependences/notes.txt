Think I need to make another more intermediate IR.
:: source -> tokens -> AST -> IR -> bash

AST      Information for semantic analysis, cursor information

IR       Should be a nearly-finished tree, though with terminal sentinel nodes
         instead of raw values. Perhaps also additional meta-information.
----

An array like:
   [ "one", "two" ]

Compiles to:
   declare -a _IR_1=(
      _IR_2
      _IR_3
   )
   declare -- _IR_2="one"
   declare -- _IR_3="two"

Hmm, IR nodes should contain...
   [symtab]    :: symbol table name this node belongs to
   [node]      :: reference back to the AST node name
   [name]      :: for convenience, node.name.value (needed? helpful?)

...but maybe only for expressions. Not sections or variable declarations.


Maybe instead compiles to:
   declare -a _IR_1=(
      _IR_2
      _IR_3
   )
   declare -A _IR_2=(
      [symtab]=_SYMTAB_2
      [node]=_NODE_2
      [value]="one"
   )
   declare -A _IR_3=(
      [symtab]=_SYMTAB_2
      [node]=_NODE_3
      [value]="two"
   )


This doesn't actually solve for the original problem of deferred compilation of
something like:
   item  : array> 1;
   array : ["one", "two"];

In the above case, we cannot determine the reference to `item` until determining
the reference of `array`, and compiling what it points to.


Build a dependency graph, and compile in order? I don't know how to do this,
even not in bash. Imagine there would be a much greater degree of complexity
here.


Hmm, I think only a tree is possible. As one variable may not be assigned to
multiple values, we must have a tree. Ultimately all variables must resolve to a
"raw" expression.


Building a tree, and assigning each node a "depth" allows us to defer references
until their prerequisites have been compiled. Should be able to then assign each
AST_NODE to a pass of the reference compiler.

Revisiting:
   item1: array> 0;
   array: [ "one", "two" ]

Pass1 compiles to:
   declare -a _IR_1=_IR_2     # item1 = unary...
   declare -a _IR_2=''        # unary [UNRESOLVED]

   declare -a _IR_3=(
      _IR_4
      _IR_5
   )
   declare -- _IR_6="one"
   declare -- _IR_7="two"

   REF_MAP=(
      [_NODE_2]=_IR_2
   )

Pass2 compiles to:
   declare -a _IR_1=_IR_2
   declare -a _IR_2=_IR_4     <--  "${_IR_3[0]}"
   ...
   REF_MAP=()


To do this...
   item1: array> 0;
   array: [ "one", "two" ]

...must become...
   # Has a reference. Everything after the reference must be of a greater depth,
   # and the "container" that holds in (in this case the unary expression) is on
   # the same level.
   _NODE_1=(
      [depth]=0
      [value]='item1'
   )
   _NODE_2=(  # unary
      [depth]=1
      [left]='_NODE_3'
      [right]='_NODE_4'
   )
   _NODE_3=(
      [depth]=1
      [value]='array'
   )
   _NODE_4=(
      [depth]=2
      [value]=0
   )

   # Building the array. Only leaf nodes here, no references.
   _NODE_5=(
      [depth]=0
      [value]='array'
      [items]='_NODE_6'
   )
   _NODE_6=(
      _NODE_7
      _NODE_8
   )
   _NODE_7=(
      [depth]=0
      [value]='one'
   )
   _NODE_8=(
      [depth]=0
      [value]='two'
   )


e: "three"
f: e
array: ["one", "two", e];
c: array> 1;
b: c
d: c
a: b

depth:

  0                                          (e: "three")
                                             /  \
  1                 (array: ["one", "two", e])(f: e)
                       |
  2              (c: array> 0)
                /   \
  3       (d: c) (b: c)
                  |
  4           (a: b)



Or more simplified:

         e
       /   \
    array   f
      |
      c
     / \
    d   b
        |
        a


So, now we know what we're *trying* to achieve. I guess that's good enough for
one night. Tomorrow we can start reasoning about the steps required to *get*
there.


Can we assume any expressions must be a 0-depth? Depends if we allow references
in arrays. If not, and they may only contain raw values, then all value leaf
nodes must be 0.

Sections and variable declarations are always 0. We can create the skeleton
itself, it is only the expressions of variable declarations that have ambiguity
in their compilation order.

Assuming:
   S1 {
      a: c;
      b: c;
      c: "this"
   }

Results in the skeleton:
   _SK_0=(
      [_SK_1]=''
      [_SK_2]=''
      [_SK_3]='_SK_4'
   )
   _SK_4='this'


We can then make a map parallel to the AST/SYMTAB that associates the AST_NODE
with the _SK_$n node.

Will additionally need a map for the depth of each AST node. While compiling,
hitting a node of greater depth causes us to create the _SK_$n node but set as
empty. Should try to make this idempotent, and using as few tests as possible.

Maybe it would honestly be faster to intitially just create the skeleton with
zero values. We then just check depth.
   if (( $DEPTH > ${DEPTH_MAP[$NODE]} )) ; then
      continue
   fi

Assuming:
   S1 {
      a: c;
      b: c;
      c: "this"
   }

Results in pass1
   _SK_0=(
      [_SK_1]=''
      [_SK_2]=''
      [_SK_3]=''
   )

Results in pass2
   _SK_0=(
      [_SK_1]=''
      [_SK_2]=''
      [_SK_3]='_SK_4'
   )
   _SK_4="this"

Results in pass3
   _SK_0=(
      [_SK_1]='_SK_3'
      [_SK_2]='_SK_3'
      [_SK_3]='_SK_4'
   )
   _SK_4="this"

Which compiles to...
   _D_0=(
      [_D_1]='_D_4'
      [_D_2]='_D_4'
      [_D_3]='this'
   )

UH OH! Hmm. I may need to think this through more. Clearly we can't just resolve
all the references by 1 level, because then refs are going to point to the
now-deleted terminal nodes.


Either way it feels like there's an edge case. Either it's an edge case where I
need to handle the terminal raw expr, or it's an edge case where I need to
handle the reference. Gotta come up with a general solution that fits for both
of them.


Gotta work through the problem above a little more.


Assuming:
   S1 {
      a: c;
      b: c> 0;
      c: [[1, 2], 3];
   }

Results in pass1
   _SK_0=(
      [_SK_1]=''
      [_SK_2]=''
      [_SK_3]=''
   )

Results in pass2
   _SK_0=(
      [_SK_1]=''
      [_SK_2]=''
      [_SK_3]='_SK_4'
   )
   _SK_4=(
      _SK_5       # [1, 2]
      _SK_6       # 3
   )
   _SK_5=(
      _SK_7       # 1
      _SK_8       # 2
   )
   _SK_6='3'
   _SK_7='1'
   _SK_8='2'

Results in pass3
   _SK_0=(
      [_SK_1]='_SK_4'      map.get('c') ->  _SK_4
      [_SK_2]='_SK_5'      map.get('c') ->  _SK_4 -> [0] -> _SK_5
      [_SK_3]='_SK_4'
   )
   _SK_4=(
      _SK_5       # [1, 2]
      _SK_6       # 3
   )                       
   _SK_5=(                 
      _SK_7       # 1
      _SK_8       # 2
   )
   _SK_6='3'
   _SK_7='1'
   _SK_8='2'

Which compiles to...
   _D_0=(
      [_D_1]='_D_4'
      [_D_2]='_D_5'
      [_D_3]='_D_4'
   )
   _D_4=(
      _D_5
      3
   )                       
   _D_5=(                 
      1
      2
   )


Maybe make helper function(s) for the below.
   function ref_is_open {
      local -n node="${NODE}"
      local -n _name="${node[name]}"
      local -- name="${_name[value]}"

      local -n symtab="${SYMTAB}"
      local -n symbol="${symtab[name]}"
      local -n target_node="${symbol[node]}"
      
      # Return if there is an open ref for this node that still must be
      resolved.
      [[ "${REF_MAP[$target_node]}" ]]
   }

   function at_depth {
      local depth="${DEPTH_MAP[$NODE]}"
      [[ $depth -eq $DEPTH ]]
   }

Can test if refs should be resolved at this level like so:
   ref_is_open || return;
   at_depth    || return;

Expressions that may have dependencies (e.g., an array with a ref as a member)
can be assessed with just:
   at_depth || return;

Huh so it seems like to get it to work, we need to have the references point not
to the variable, but to point to the expression. Which I believe is what I
actually tried in a4860532c23d or so. Getting back to the problem that didn't
work above again.

Assuming:            #          AST NODES
   S1 {              #  S1's expr  ::  AST1 (section)
      a: c;          #  a's  expr  ::  AST2 (identifier, value: 'c')
      b: c> 0;       #  b's  expr  ::  AST3 (index, left: 'c', right: 0)
      c: [1, 2];     #  c's  expr  ::  AST4 (array, items: [AST5, AST6])
   }

Pass 0.
Create a skeleton with every node in the symbol table. Expressions are left
empty and compiled next. Can honestly probably fill in "raw" expressions in this
phase as well.
   SK0=(
      [SK1]=''
      [SK2]=''
      [SK3]=''
   )

Pass 1.
   SK0=(             #    EXPR_MAP{}
      [SK1]=''       #  
      [SK2]=''       #  
      [SK3]='SK4'    #
   )                 #
   SK4=(             #   AST4  ->  SK4
      SK5            #
      SK6            #
   )                 #
   SK5=1             #   AST5  ->  SK5
   SK6=2             #   AST6  ->  SK6

Pass 2.
   SK0=(
      [SK1]='SK4'    #  symtab['c'] -> AST4 -> EXPR_MAP['AST4'] -> SK4
      [SK2]='SK5'    #  symtab['c'] -> AST4 -> EXPR_MAP['AST4'] -> SK4 -> [0]
      [SK3]='SK4'
   )
   SK4=(
      SK5
      SK6
   )
   SK5=1
   SK6=2

Shit, same problem with leaf expressions. The reference needs to resolve twice
to the value itself, instead of the name of the value. This is **not** the case
with arrays/sections though. Bah.

Maybe if we try again without the intermediate variable for terminal exprs?

Assuming:            #          AST NODES
   S1 {              #  S1's expr  ::  AST1 (section)
      a: c;          #  a's  expr  ::  AST2 (identifier, value: 'c')
      b: c> 0;       #  b's  expr  ::  AST3 (index, left: 'c', right: 0)
      c: [1, 2];     #  c's  expr  ::  AST4 (array, items: [AST5, AST6])
   }

Pass 0.
Create a skeleton with every node in the symbol table. Expressions are left
empty and compiled next. Can honestly probably fill in "raw" expressions in this
phase as well.
   SK0=(
      [SK1]=''
      [SK2]=''
      [SK3]=''
   )

Pass 1.
   SK0=(             #    EXPR_MAP{}
      [SK1]=''       #  
      [SK2]=''       #  
      [SK3]='SK4'    #
   )                 #
   SK4=(             #   AST4  ->  SK4
      1              #   AST5  ->  '1'
      2              #   AST6  ->  '2'
   )                 #

Pass 2.
   SK0=(
      [SK1]='SK4'    #  symtab['c'] -> AST4 -> EXPR_MAP['AST4'] -> SK4
      [SK2]='1'      #  symtab['c'] -> AST4 -> EXPR_MAP['AST4'] -> SK4 -> [0]
      [SK3]='SK4'
   )
   SK4=(
      1
      2
   )


Huh. Seems the approach I was going with originally does work... don't need the
IR at all, but I do need some way of first generating the dependency tree.


Okay.


Now just need to figure out how to build the dependency graph. Every single
expression AST node needs to be tagged with its depth. Barf, gotta think through
what something being a dependency **means**.

1) This is only something that we have to consider with references. If there's no
   references, there are no dependencies.

2) If we hit a reference, it is dependent upon the expressions downstream of the
   var to which it points.

Examples:
   a: "one";   #> AST_1
   b: a;       #> AST_2

`b` is dependent upon `a`'s expression. Or more accurately... AST_2 is dependent
upon AST_1, and everything downstream of it.

Maybe try adding a ref to the NODE itself?
   AST_2=(
      [type]='identifier'
      [value]='a'
      ...
      [depth]=                   # To be added after/while constructing the tree
      [depends]='DEP_AST_2'      # Pointer to the dependencies of this expr.
   )
   DEP_AST_2=(
      AST_1
   )


Walk the tree bottom to top. Hitting the raw leaf expressions will always be
depth 0. Anything terminating in a [int, str, bool, path].


Bah. Needs to think through more.


So what cases are things "downstream"?
   a: [1, 2];
   b: a;
   c: b> 0;
   # c deps [b]
   # b deps [a]
   
   a: [1, 2];
   b: a> c;
   c: 0;
   # b deps [a, c]

   a: [1, 2];
   b: a> c;
   c: d;
   d: 0
   # b deps [a, c]
   # c deps [d]


"Dependencies" are really just>  "does this variable declaration contain
references to other expressions? they are dependencies."

Walk the tree, upon hitting a variable declaration, store the dependency KEY.
E.g., what is dependent upon any potential references in its expr. For the
above...
   parsing `a`, reset DEPS[], find no refs in expr, continue
         DEPS+=( 'AST_1_DEPS' )
         AST_1_DEPS=( "${DEPS[@]}" )
   parsing `b`, reset DEPS[], find both `a` and `c`, resolve & push to $DEPS[]
         DEPS+=( 'AST_2_DEPS' )
         AST_2_DEPS=( "${DEPS[@]}" )
   parsing `c`, reset DEPS[], find `d`, resolve & push to $DEPS[]
         DEPS+=( 'AST_3_DEPS' )
         AST_3_DEPS=( "${DEPS[@]}" )

Then iterate over all of the nodes that have dependencies. I believe this will
pretty much just be variable declarations, and sections? (Gotta think about
sections too). Both of these are in the symbol table. Do we just add all this
information to the symbol table...? Iterate the symtab, and output a new
re-orderd AST?

(Sidebar: I don't think I need to take sections into account at all. We can
build all the sections at any time. They're part of the "skeleton". Can't be
impacted by another expression.)

Hmm. For each of the symbol:deps[] arrays, need to count how many chains of
pointers there are. E.g..

   a: [1, 2];          a   d
   b: a> c;            |  /
   c: d;               | c
   d: 0                |/
                       b

   a: []
   b: [a, c]
   c: [d]
   d: []

   ---

   a: []               :: 0
   b: [
         a -> []       :: 1
         c -> d -> []  :: 2
      ]
   c: d -> []          :: 1
   d: []               :: 0

   b must resolve after its deps, so it gets max(b.deps).

   ---
   # What about something that has multiple tier 2 deps?

               a   d   f      0
               |   |   |
               |   |   e      1
               |   | /
               \   c          2
                \ /
                 b            3

   a: []
   b: [a, c]
   c: [d, e]
   d: []
   e: [f]
   f: []

   ---
   # Ugh, really not sure how to write this in bash. Maybe try to draft out
   # something in python first, and then translate to bash? This is written very
   # bash-y, to make the transition easier. Works though.

   a = []           # 0
   b = ['a', 'c']   #    3
   c = ['d', 'e']   #   2
   d = []           # 0
   e = ['f']        #  1
   f = []           # 0
   
   def get_depth(node, level=0):
      if len(node) == 0:
         return level

      levels = []
      for n in node:
         levels.append(get_depth(eval(n), level+1))

      max = levels[0]
      for i in levels:
         if i > max:
               max = i

      return max

   ---
   # Put unordered nodes into ordered level of depth.

   unordered=()
   ordered=()

   (( i=0 ))
   
   while (( ${#unordered[@]} > 0 )) ; do
      for idx in "${!unordered[@]}" ; do
         num=${unordered[$idx]}
         if (( num == i )) ; then
            unset 'unordered[$idx]'
            ordered+=( $num )
         fi
      done
      (( ++i ))
   done


With this figured out, should be able to do 2 passes, irrespective of the number
of dependent expressions.

Pass 1:  create the "skeleton", EXPR_MAP, and dependency tree
   Create an associative arracy for each section. All child variables have a key
   and empty function declared to hold their expression. All child sections have
   a key and corresponding associative array.

   ---
   # Input.
                              #  Node name for the EXPRESSIONS
   S0 {                       #  AST1
      one: 1;                 #  AST2
      two; S0> S1> three;     #  AST3

      S1 {                    #  AST4
         three: 3;            #  AST5
      }
   } 

   ---
   # Skeleton of the config, only keys & sections filled in.

   declare -A ROOT=(
      [S0]=D1
   )
   declare -A D1=(
      [one]=D2
      [two]=D3
      [S1]=D4
   )
   declare -- D2=
   declare -- D3=
   declare -A D4=(
      [three]=D5
   )
   declare -- D5=

   ---
   # Expr map.
   declare -a EXPR_MAP=(
      [AST1]=D1
      [AST2]=D2
      [AST3]=D3
      [AST4]=D4
      [AST5]=D5
   )

   ---
   # Dependency tree.
   AST1_DEP=()                      # 0
   AST2_DEP=()                      # 0
   AST3_DEP=( AST1  AST4  AST5 )    #  1
   AST4_DEP=()                      # 0
   AST5_DEP=()                      # 0

   PARSE_ORDER=(
      AST1                          # 0
      AST2                          # 0
      AST4                          # 0
      AST5                          # 0
      AST3                          #  1
   )

Pass 2:  parse in order, compile the expression and assign to its corresponding
EXPR node.
   for src in "${PARSE_ORDER[@]}" ; do
      dst="${EXPR_MAP[$src]}"
      compile  "$src"  "$dst"
   done

Can re-use pretty much the entire existing compiler, just split into two. The
compilation of section/variable declarations is pass 1, in which we only need to
walk expressions to find identifiers, and add things to the EXPR_MAP. All the
expression compiling stuff can largely stay almost exactly the same, except
pointing to the newly passed in $dst to drop the data, rather than the global
$DATA pointer.

May help if we actually just set a global pointer for the destination. Will
potentially need to unset & recreate the variable. In case it was created as
`--`, and should be `-a` or `-A`. Not positive how that works.

Looks like you can remap a raw `declare FOO` declaration.

Global pointer will effectively tell it what name to use for the top level
variable.

Hmm, not sure if this will work. If you need to make a complex expr, array of
arrays, I don't know how it could only have the top level item use the global
var, but everything else create new expressions. Hmm.

Maybe just have walk_compiler1 call _walk_compiler1. The first one sets the
initial global variable, the second is what is called during compilation?


----
2022-10-21
Sections being an edge case is actually chuckin' a wrench in things. When trying
to do some subscription of a key within the section, it's nameref'ing the
variable twice.

Once to select the node:
   SKELLY_1=DATA_1         <-- "DATA_1"
   DATA_1="value"

Second time to reference the held value:
   SKELLY_1=DATA_1
   DATA_1="value"          <-- "value"

Maybe if we also generate an intermediate SKELLY node for sections?

--
Given.
   S0 {
      one: 1;
   }
   _: S0> one;

--
Compiled.
   ROOT=(
      [%inline]=SKELLY1
   )

   # %inline section
   SKELLY1=SKELLY2
   SKELLY2=(
      [S0]=SKELLY3
      [_]=''
   )

   # S0 section
   SKELLY3=SKELLY4
   SKELLY4=(
      [one]=''
   )

--
Folding.

