= conflang
:toc:                      left
:toclevels:                3
:source-highlighter:       pygments
:pygments-style:           algol_nu
:pygments-linenums-mode:   table

Declarative config file "`language`" with built-in validation.


== Why it do

Another stepping stone in my path to write a programming language.

Many projects in the last few years have been geared towards incrementally writing a programming language.
I consistently find myself hitting sticking points.
Stemming from both the gaps in my non-existent CS education, as well as difficulties approaching design problems.
Smaller scale projects, like this one, help me to work through specific conceptual slices.

This is the spiritual successor to `mkconf`, `conf`, and `shql`.
Each better than the last.

I do not intend for anyone to actually use `conflang`, just as I didn't write `shql` to be used.
The project is in the designing/writing itself.


== How it look

First thing anyone wants to see is some example syntax.

.Features snapshot
----
# Key value pairs.
name : "Marcus";
age  : 30;

# Basic types.
name (str): "Marcus";

# Complex types.
names (array:str): [
   "Marcus",
   "Aurelius",
];

# Sections.
globals {
   scope: "outer";

   sub-heading {
      scope: "inner";
   }
}

# Environment variables.
homedir (path): $HOME;

# Internal variables.
homedir_copy: %homedir;

# String interpolation.
project_dir : "{$HOME}/projects/";
sub_dir     : "{%project_dir}/sub/";

# Import other files.
%include './sub-file.conf';

# Enforce constraints on child-config files.
%constrain [
   "./sub1.conf",
   "./sub2.conf",
];
----

.Example '`real`' file
----
common {
   colors (array:str) [
      "#hex...";
      "#hex...";
      "#hex...";
      "#hex...";
      "#hex...";
      "#hex...";
      "#hex...";
   ];
}

window {
   geometry {
      height (int): 100;
      width  (int): 80;
   }

   theme {
      foreground: %common.colors.0;
      foreground: %common.colors.1;
   }
}

%include './bindings.conf';
----


== What it about

Writing small shell files that take configuration parameters can be tricky and tiresome.
Do you trust the user's input, or validate everything?
How to handle idempotency?
For an important utility (backups, managing services) it is vital that input is valid.
Crashing half way through a backup because an intermediate path does not exist is bad.
There are often many ways to handle data type mismatches, or invalid input.

I hope to resolve some of those problems with:

. Declarative, validated, strongly-typed configuration files
. Easily accessible parameters for the developer
. Simple to configure for end users
  .. With _optional_ room to add validation & complexity
. Good error reporting for everyone


== How you use
=== Developers
=== End users
