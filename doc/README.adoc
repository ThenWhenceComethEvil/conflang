= conflang
:toc:                      left
:toclevels:                3
:source-highlighter:       pygments
:pygments-style:           algol_nu
:pygments-linenums-mode:   table

Declarative config file "`language`" with built-in validation.


== Why it do

Another stepping stone in my path to write my own programming language.

Many projects in the last few years have served that goal.
I consistently find myself hitting sticking points.
Stemming from both the gaps in my non-existent CS education, as well as difficulties approaching design problems.
Smaller scale projects, like this one, help me to work through specific conceptual slices.

This is the spiritual successor to `mkconf`, `conf`, and `shql`.
Each better than the last.

I do not intend for anyone to actually use `conflang`, just as I didn't `shql`.
Journey over destination and all that.


== How it look

First thing anyone wants to see is some example syntax.

.Features snapshot
----
# Key value pairs.
name : "Marcus";
age  : 30;

# Basic types.
name (str): "Marcus";

# Complex types.
names (array:str): [
   "Marcus",
   "Aurelius",
];

# Sections.
globals {
   scope: "outer";

   sub-heading {
      scope: "inner";
   }
}

# Environment variables.
homedir (path): $HOME;

# Internal variables.
homedir_ref: %homedir;

# String interpolation.
project_dir : '{$HOME}/projects/';
sub_dir     : '{%project_dir}/sub/';

# Type casting.
shell_level : $SHLVL -> int;

# Import other files.
%include './sub-file.conf';

# Enforce constraints on child-config files.
%constrain [
   "./sub1.conf",
   "./sub2.conf",
];
----

.Example '`real`' file
----
common {
   colors (array:str) [
      "#hex...";
      "#hex...";
      "#hex...";
   ];
}

window {
   geometry {
      height (int): 100;
      width  (int): 80;
   }

   theme {
      foreground: %common.colors.0;
      foreground: %common.colors.1;
   }
}

%include './bindings.conf';
----


== What it about

Configuration files are the backbone of unix systems.
Most every application/tool uses one.

They have many common problems.

=== Documentation
Unless the project maintainer was a benevolent god, thoroughly documenting the file itself, it can be difficult to determine what keys are required or values are expected.
Is a boolean looking for `true` or `True`, or maybe just anything _truthy_?
Should integers be in quotes, or standalone?
Can I include environment variables?
What about references to other config variables, to keep my code _DRY_.

Who knows.

=== Weak typing
By their nature, configuration files are untyped.
Even more modern file formats (json, yaml, toml) don't even have type hinting, let alone strong type requirements.
For configuring utilities as critical a backup application, or system monitoring services, typing is necessary.

No script should fail due to semantic oversights in the configuration.

=== Inconsistent validation
Validating a configuration file is left entirely to the program author.
The extent to which they attempt to catch & appropriately handle edge cases can vary wildly.
Error reporting is often cryptic, or non-existent.

Programmers don't want to spend their time validating user input.
Shifting that responsibility to the config file itself allows them to write code.


== How you use
=== Developers
=== End users
