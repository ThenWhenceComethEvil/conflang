= Notes
:toc:                      left
:toclevels:                3
:source-highlighter:       pygments
:pygments-style:           algol_nu
:pygments-linenums-mode:   table

Collections of my thinkies, musings, and stuff to refer back to while working on this.


== Bash tomfoolery
Naturally, any project of mine must contain a fair amount of bash tomfoolery.

=== Set, but empty
There are built-in tests for variables that are empty _or_ unset (`test -z`).
However none for declared _and_ empty.
Did some testing to verify how all the parameter expansion for unset/empty vars works:

[source,bash]
----
# Set, empty.
declare -- se=

# Set, non-empty.
declare -- ne='set'

# Non-set
#declare -- ns

#    TEST                          #      SET      VALUE     RESULT   
#---------------------------------------------------------------------
[[ ${ne}     ]] && echo  "ne"      #      YES       YES      TRUE
[[ ${se}     ]] && echo  "se"      #      YES        NO      FALSE
[[ ${ns}     ]] && echo  "ns"      #       NO       ---      FALSE

[[ ${ne-_}   ]] && echo  "ne-_"    #      YES       YES      TRUE
[[ ${se-_}   ]] && echo  "se-_"    #      YES        NO      FALSE
[[ ${ns-_}   ]] && echo  "ns-_"    #       NO       ---      TRUE

[[ ${ne:-_}  ]] && echo  "ne:-_"   #      YES       YES      TRUE
[[ ${se:-_}  ]] && echo  "se:-_"   #      YES        NO      TRUE
[[ ${ns:-_}  ]] && echo  "ns:-_"   #       NO       ---      TRUE

[[ ${ne+_}   ]] && echo  "ne+_"    #      YES       YES      TRUE
[[ ${se+_}   ]] && echo  "se+_"    #      YES        NO      TRUE
[[ ${ns+_}   ]] && echo  "ns+_"    #       NO       ---      FALSE

[[ ${ne:+_}  ]] && echo  "ne:+_"   #      YES       YES      TRUE
[[ ${se:+_}  ]] && echo  "se:+_"   #      YES        NO      FALSE
[[ ${ns:+_}  ]] && echo  "ns:+_"   #       NO       ---      FALSE

# TO USE...
# Find a section in which the desired value has a unique result. E.g., where
# the result of ${ns...} is not the same as the result of `ne` or `se`.

# Results...
#  UNSET              [[ ! ${var+_} ]]
#  SET AND EMPTY      [[ ! ${var-_} ]]
#  SET AND NONEMPTY   [[   ${var}   ]]
----


== Subtypes
Would be nice to have subtypes for paths.
`path:file`, `path:directory`, etc.

The typecheck an say it's not a directory, because it doesn't end in a trailing slash.
But the runtime validation will check if the file itself actually is a directory.


== Basic grammar
----
program        -> statement EOF

statement      -> parser_directive
                | declaration

declaration    -> section_decl
                | variable_decl

section_decl   -> identifier '{' declaration* '}'

variable_decl  -> identifier (type)? (expression)? ';'

expression     -> array
                | string
                | integer
                | boolean
                | path

array          -> '[' expression* ']'
----


== Basic syntax
[source]
----
untyped {
   key1  "value1";
   key2  "value2";
}


typed {
   key1  str  "value1";
   key2  array:str  [
      "one"
      "two"
      "three"
   ];
}


context {
   directories  array:path  [
      ~/Documents
      ~/Desktop
   ] {
      readable    # directive:  must be readable, `chmod +r`
      writable?   # test:       is writable? fail if not.
   }
}
----


== Variables
=== Bash variables
How should bash variables work?

.Options
. Only allow for basic variables: `$VAR`
  .. Additionally allow `${VAR}` style
. Include support for basic array indexing: `${VAR[0]}`
. Include support for complex array operations (slices?): `${VAR[0:-2]}`

There's a slight deviation from traditional bash syntax in these arrays.
At that point, I may as well just use a better syntax, raerpb Bash's kinda convoluted approach.
I do need a syntax to separate environment variables from internal variables.
I can make these function calls tbh.

.idea #1, function calls
[source,conf]
----
global {
   path  env("PATH");
   name  self("user", "name");
}

user {
   name "Marcus";
   age  30;
}
----

The functions are variatic, and effective take a series of indices.
They would work in the same way the `api.conf()` function does.
Cannot do static typechecking, would need to be runtime in the compiler.
Though can use the type information in nifty ways.

_AS IT TURNS OUT... I FORGOT SOMETHING IMPORTANT._

I don't need to worry about indexes at all.
Bash does not support exporting an array into the environment.
It's a known bash bug that I've run into once or twice in the past.
Makes it way easier to pull in vars from the environment when they can only be simple key:value pairs.
Though still need a way to pull '`internal`' vars.
Saves repetition.

.idea #2, simple vars
[source,conf]
----
global {
   path  $PATH;
}
----


=== Internal variables
First idea is to just use a different prefix to designate internal variables.
This has the approach of being distinct from environment variables.
Though could lead one to mistakenly use `$` over `%`.

.idea #1, different prefix
[source,conf]
----
global {
   people [
      %user1.name
      %user2.name
   ];
}

user1 {
   name "Marcus";
}

user2 {
   name "Ginny";
}
----


=== String interpolation
Should string interpolation be able to handle arbitrary expressions?
Currently I think not.
There really aren't any expressions in the language.
It would really just be '`internal`' or environment variables.

[source,conf]
----
global {
   full  "%{user1.name} Aurelius";
   repo  "${HOME}/hg";
}

user1 {
   name  "Marcus";
}
----

I think the above examples definitely demonstrate the difficulty in distinguishing between `$`/`%`.
Other symbols I can use?


== What do I work on now?
For when I get stuck, what are things I can work on...

* [ ] Error handling
* [x] Referencing bash environment variables
* [x] Referencing interal variables?
* [x] BATS tests
* [x] Merging child file -> parent
* [x] Lexing, parsing, and compiling basic (non-directive) .config files
* [x] Support for basic type checking
* [x] Accessing variables from .config file
* [x] Importing/including/extending to other .config files
* [x] Directive/test contexts
* [x] Error reporting


== Built-in dates

Dates are a natural thing to natively support.
Need to think of a syntax that's good.
May contain an optional output format, as defined by `date`.
The input format is defined by `date --date`.

.Input format for date
[source]
----
The --date=STRING is a mostly free format human readable date string such as
"Sun, 29 Feb 2004 16:21:42 -0800" or "2004-02-29 16:21:42" or even "next
Thursday". A date string may contain items indicating calendar date, time of
day, time zone, day of week, relative time, relative date, and numbers. An
empty string indicates the beginning of the day. The date string format is more
complex than is easily documented here but is fully described in the info
documentation.
----


== Syntax 2: Electric Fuckmealoo

My intent was to make a syntax that was simple, easy to read, and easy to write.
Eliminating delimiters between array elements, `=` or `:` in variable declarations serve this goal.
It adds a simplicity in legibility, and a simplicity in refactoring.

Unfortunately any simplicity that's provided is invalidated by the difficulty in parsing, and lack of clear error reporting.

My initial design influence was the easy of writing nginx config files.
Blocks are easily defined by squiggly braces.
Keys are simple identifiers, followed by a value terminated by a semicolon.

We may need to add minimal symbols to aid in parsing, but moreso anchor the error reporting.
(This is most obvious when running into an unexpected token in an array.)

.New syntax
[source]
----
# Section declarations remain the same.
section {
   # ...
}

# Variable declarations are as follows.
var;                       # 1. Raw declaration: no type, no value
var (str);                 # 2. Declaration w/ type, no value
var: "value";              # 3. Declaration w/ value, no type
var (str): "value";        # 4. Declaration with type and value

# Arrays will need a delimiter. Final element may still have delim after it.
# PS fuck you json.
var (array:str): [
   "one",
   "two",
];
----

I'm not sold on the typedefs right now.
Surround with parens may be unnecessary.
Not one hundy on the colon separator either.

.What about

[source]
----
var str: "this";
var array: [ ... ];
var array[str]: [ ... ];
----

It's interesting, though types strictly have a singular subtype.
Don't need a bracket, as we cannot have something such as:
`hash[int, string]`.

.Straight-up shotgunning ideas here
[source]
----
var array->str: [ "str" ];
var array->array->str:  [["s1"], ["s2"]];

var array/string: ...
# ^-- no, this looks like an option
----

The `/` syntax is interesting, but I think as an "internal variable" syntax.
Currently all internal vars must start at the root, and provide a full path.
Sorta defeats the purpose of having lexical scoping in sections if we can't
do relative vars. What about...

.Variables are paths
[source]
----
global {
   items (array:str) {
      "one",
      "two",
      "three",
   }

   item_one (str): .items/0;
}

item_two (str): /global/items/0;
----

I think it's honestly a pretty neat syntax, and instantly understandable from a unix perspective...
except for a configuration file format with a native '`path`' data type, it's obvious to mistake this syntax with an actual directory path.

I've always thought that a ``/``-separated (raerpb `.` or `[index]`) is better.
Naturally indicates absolute vs. relative indexes, and feels very "familiar".

Just not right for this context.

For now going to use types surrounded by parens, with a colon separating the expression.
Array elements will be delimited by a comma.


== Next steps

From here, need to
   1. Change how constrain works
      - The result of an `identify_constraint_file` should be appending a single
        file to FILES[]. The precedence should operate top -> bottom, in which
        the highest prec is on the bottom. The function will iterate and return
        the last file found. Example: ['found', 'found', 'not found'] would
        return the file at index 1.
      - There must be at least one constrain file found (if there is a constrain
        statement), else a parse error is thrown.
   2. Change where %use statements are "compiled"
      - Realistically, %use statements aren't "compiled". They're kinda just
        entered into the symbol table under a new name. Example, 'std/math' may
        go into the symtab as ['math']=Symbol(['fn']='_aabbcc').
      - These should be parsed and entered into the symtab just after the built-
        in symbols (int, str, bool, type, etc.).

Running list of things that will be necessary for this to work:
 - [ ]. Types as a valid expression
          - Requires changing how subscription works, everything will need to
            shift to bracket syntax
          - Honestly this is a better approach that we should've shifted to
            some time ago
          - Allows the user to supply a .conf file with their module that
            states permissible types
 - [ ]. Compiling a type expression returns the name of the compiled TYPE_$n
        node.
          - May be useful in situations such as this one in which using a
            type as value should return the TYPE to the programmer
          - There may also be situations useful for end users for this
            behavior
          - Takes us one step closer to being able to call functions from the
            global scope. Maybe internal references don't need to use '%'
            afterall, save it for parser statements
