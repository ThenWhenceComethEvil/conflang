= Notes
:toc:                      left
:toclevels:                3
:source-highlighter:       pygments
:pygments-style:           algol_nu
:pygments-linenums-mode:   table

Collections of my thinkies, musings, and stuff to refer back to while working on this.


== Bash tomfoolery
Naturally, any project of mine must contain a fair amount of bash tomfoolery.

=== Set, but empty
There are built-in tests for variables that are empty _or_ unset (`test -z`).
However none for declared _and_ empty.
Did some testing to verify how all the parameter expansion for unset/empty vars works:

[source,bash]
----
# Set, empty.
declare -- se=

# Set, non-empty.
declare -- ne='set'

# Non-set
#declare -- ns

#    TEST                          #      SET      VALUE     RESULT   
#---------------------------------------------------------------------
[[ ${ne}     ]] && echo  "ne"      #      YES       YES      TRUE
[[ ${se}     ]] && echo  "se"      #      YES        NO      FALSE
[[ ${ns}     ]] && echo  "ns"      #       NO       ---      FALSE

[[ ${ne-_}   ]] && echo  "ne-_"    #      YES       YES      TRUE
[[ ${se-_}   ]] && echo  "se-_"    #      YES        NO      FALSE
[[ ${ns-_}   ]] && echo  "ns-_"    #       NO       ---      TRUE

[[ ${ne:-_}  ]] && echo  "ne:-_"   #      YES       YES      TRUE
[[ ${se:-_}  ]] && echo  "se:-_"   #      YES        NO      TRUE
[[ ${ns:-_}  ]] && echo  "ns:-_"   #       NO       ---      TRUE

[[ ${ne+_}   ]] && echo  "ne+_"    #      YES       YES      TRUE
[[ ${se+_}   ]] && echo  "se+_"    #      YES        NO      TRUE
[[ ${ns+_}   ]] && echo  "ns+_"    #       NO       ---      FALSE

[[ ${ne:+_}  ]] && echo  "ne:+_"   #      YES       YES      TRUE
[[ ${se:+_}  ]] && echo  "se:+_"   #      YES        NO      FALSE
[[ ${ns:+_}  ]] && echo  "ns:+_"   #       NO       ---      FALSE

# TO USE...
# Find a section in which the desired value has a unique result. E.g., where
# the result of ${ns...} is not the same as the result of `ne` or `se`.

# Results...
#  UNSET              [[ ! ${var+_} ]]
#  SET AND EMPTY      [[ ! ${var-_} ]]
#  SET AND NONEMPTY   [[   ${var}   ]]
----


== Subtypes
Would be nice to have subtypes for paths.
`path:file`, `path:directory`, etc.

The typecheck an say it's not a directory, because it doesn't end in a trailing slash.
But the runtime validation will check if the file itself actually is a directory.


== Basic grammar
----
program        -> statement EOF

statement      -> parser_directive
                | declaration

declaration    -> section_decl
                | variable_decl

section_decl   -> identifier '{' declaration* '}'

variable_decl  -> identifier (type)? (expression)? ';'

expression     -> array
                | string
                | integer
                | boolean
                | path

array          -> '[' expression* ']'
----


== Basic syntax
[source]
----
untyped {
   key1  "value1";
   key2  "value2";
}


typed {
   key1  str  "value1";
   key2  array:str  [
      "one"
      "two"
      "three"
   ];
}


context {
   directories  array:path  [
      ~/Documents
      ~/Desktop
   ] {
      readable    # directive:  must be readable, `chmod +r`
      writable?   # test:       is writable? fail if not.
   }
}
----


== Variables
=== Bash variables
How should bash variables work?

.Options
. Only allow for basic variables: `$VAR`
  .. Additionally allow `${VAR}` style
. Include support for basic array indexing: `${VAR[0]}`
. Include support for complex array operations (slices?): `${VAR[0:-2]}`

There's a slight deviation from traditional bash syntax in these arrays.
At that point, I may as well just use a better syntax, raerpb Bash's kinda convoluted approach.
I do need a syntax to separate environment variables from internal variables.
I can make these function calls tbh.

.idea #1, function calls
[source,conf]
----
global {
   path  env("PATH");
   name  self("user", "name");
}

user {
   name "Marcus";
   age  30;
}
----

The functions are variatic, and effective take a series of indices.
They would work in the same way the `api.conf()` function does.
Cannot do static typechecking, would need to be runtime in the compiler.
Though can use the type information in nifty ways.

_AS IT TURNS OUT... I FORGOT SOMETHING IMPORTANT._

I don't need to worry about indexes at all.
Bash does not support exporting an array into the environment.
It's a known bash bug that I've run into once or twice in the past.
Makes it way easier to pull in vars from the environment when they can only be simple key:value pairs.
Though still need a way to pull '`internal`' vars.
Saves repetition.

.idea #2, simple vars
[source,conf]
----
global {
   path  $PATH;
}
----


=== Internal variables
First idea is to just use a different prefix to designate internal variables.
This has the approach of being distinct from environment variables.
Though could lead one to mistakenly use `$` over `%`.

.idea #1, different prefix
[source,conf]
----
global {
   people [
      %user1.name
      %user2.name
   ];
}

user1 {
   name "Marcus";
}

user2 {
   name "Ginny";
}
----


=== String interpolation
Should string interpolation be able to handle arbitrary expressions?
Currently I think not.
There really aren't any expressions in the language.
It would really just be '`internal`' or environment variables.

[source,conf]
----
global {
   full  "%{user1.name} Aurelius";
   repo  "${HOME}/hg";
}

user1 {
   name  "Marcus";
}
----

I think the above examples definitely demonstrate the difficulty in distinguishing between `$`/`%`.
Other symbols I can use?


== What do I work on now?
For when I get stuck, what are things I can work on...

* [ ] Error handling
* [ ] Referencing bash environment variables
* [ ] Referencing interal variables?
* [x] BATS tests
* [x] Merging child file -> parent
* [x] Lexing, parsing, and compiling basic (non-directive) .config files
* [x] Support for basic type checking
* [x] Accessing variables from .config file
* [x] Importing/including/extending to other .config files
* [x] Directive/test contexts
* [x] Error reporting


== Built-in dates

Dates are a natural thing to natively support.
Need to think of a syntax that's good.
May contain an optional output format, as defined by `date`.
The input format is defined by `date --date`.

.Input format for date
[source]
----
The --date=STRING is a mostly free format human readable date string such as
"Sun, 29 Feb 2004 16:21:42 -0800" or "2004-02-29 16:21:42" or even "next
Thursday". A date string may contain items indicating calendar date, time of
day, time zone, day of week, relative time, relative date, and numbers. An
empty string indicates the beginning of the day. The date string format is more
complex than is easily documented here but is fully described in the info
documentation.
----
